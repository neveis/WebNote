#pragma once#include <string>#include <map>#include <memory>#include <unordered_map>#include <regex>#include <istream>namespace MyWeb {	using namespace std;	class Request	{	public:		typedef unordered_map<string, string> Cookies;		Request();		~Request();		string getMethod() const;		string getPath() const;		string getHttpVersion() const;		string getHeader(const string& key) const;		string getCookie(const string& key) const;		string getQuery(const string& key) const;		string getBody(const string& key) const;		string getRawBody();		bool hasCookie(const string& key) const;		bool hasBody(const string& key) const;		bool hasQuery(const string& key) const;		void setRawBody(const string& str);		friend shared_ptr<Request> parseRequest(istream &stream);		friend Cookies parseCookies(string str);	private:		string method, path, httpVersion, queryStr;		shared_ptr<istream> content;		unordered_map<string, string> header;		unordered_map<string, string> query;		unordered_map<string, string> body;		string rawBody;		Cookies cookies;		smatch path_match;		void parseBody(string str);	};	shared_ptr<Request> parseRequest(istream &stream);	Request::Cookies parseCookies(string str);}inline std::string MyWeb::Request::getMethod() const {    return method;};inline std::string MyWeb::Request::getPath() const {    return path;};inline std::string MyWeb::Request::getHttpVersion() const {    return httpVersion;};inline std::string MyWeb::Request::getHeader(const std::string & key) const{    auto it = header.find(key);    if (it != header.end()) {        return it->second;    }    else {        return std::string();    }}inline std::string MyWeb::Request::getCookie(const std::string & key) const{    auto it = cookies.find(key);    if (it != cookies.end()) {        return it->second;    }    else {        return std::string();    }}inline std::string MyWeb::Request::getQuery(const std::string & key) const{    auto it = query.find(key);    if (it != query.end()) {        return it->second;    }    else {        return std::string();    }}inline std::string MyWeb::Request::getBody(const std::string & key) const{    auto it = body.find(key);    if (it != body.end()) {        return it->second;    }    else {        return std::string();    }}inline void MyWeb::Request::setRawBody(const std::string & str){    rawBody = str;    parseBody(str);}inline bool MyWeb::Request::hasCookie(const std::string &key) const {    auto it = cookies.find(key);    if (it != cookies.end()) {        return true;    }    else {        return false;    }}inline std::string MyWeb::Request::getRawBody() {    return rawBody;}inline bool MyWeb::Request::hasBody(const std::string &key) const {    auto it = body.find(key);    if (it != body.end()) {        return true;    }    else {        return false;    }}inline bool MyWeb::Request::hasQuery(const std::string &key) const {    auto it = query.find(key);    if (it != query.end()) {        return true;    }    else {        return false;    }}